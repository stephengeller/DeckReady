#!/usr/bin/env bash
set -euo pipefail

# -----------------------
# Resolve repo paths (no npm link needed)
# -----------------------
# Resolve the real location of this script (follow symlinks)
SOURCE="${BASH_SOURCE[0]}"
while [ -h "$SOURCE" ]; do # resolve $SOURCE until the file is no longer a symlink
  DIR="$(cd -P "$(dirname "$SOURCE")" >/dev/null 2>&1 && pwd)"
  TARGET="$(readlink "$SOURCE")"
  if [[ "$TARGET" == /* ]]; then
    SOURCE="$TARGET"
  else
    SOURCE="$DIR/$TARGET"
  fi
done
SCRIPT_DIR="$(cd -P "$(dirname "$SOURCE")" >/dev/null 2>&1 && pwd)"
# Prefer globally linked bins (via npm link) so this works from anywhere.
# Fallback to local sibling scripts when running from the repo directly.
RUN_LUCKY_BIN="${RUN_LUCKY_BIN:-run-lucky}"
SPOTIFY_LIST_BIN="${SPOTIFY_LIST_BIN:-spotify-list}"
TIDAL_LIST_BIN="${TIDAL_LIST_BIN:-tidal-list}"
RUN_LUCKY_LOCAL="$SCRIPT_DIR/run-lucky"
SPOTIFY_LIST_LOCAL="$SCRIPT_DIR/spotify-list"
TIDAL_LIST_LOCAL="$SCRIPT_DIR/tidal-list"
if [[ -x "$RUN_LUCKY_LOCAL" && -x "$SPOTIFY_LIST_LOCAL" && -x "$TIDAL_LIST_LOCAL" ]]; then
  RUN_LUCKY_BIN="$RUN_LUCKY_LOCAL"
  SPOTIFY_LIST_BIN="$SPOTIFY_LIST_LOCAL"
  TIDAL_LIST_BIN="$TIDAL_LIST_LOCAL"
fi

# -----------------------
# Config defaults
# -----------------------
REPO_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
OUT_DIR="${OUT_DIR:-$REPO_ROOT/.downloads}"
QUALITY="${QUALITY:-LOSSLESS}"
DRY_RUN="${DRY_RUN:-0}"
TRACKLIST_FILE=""
DO_CONVERT=0
FLAC_ONLY=0
VERBOSE=0
QUIET=0
RUN_LUCKY_EXTRA=()

usage() {
  cat <<EOF
Usage:
  $(basename "$0") <spotify_url|tidal_url|tracklist_file> [options]

Options:
  --dir DIR            Output directory for downloads (default: <repo>/.downloads)
  --quality Q          LOW, HIGH, LOSSLESS, HI_RES_LOSSLESS (default: $QUALITY)
  --dry                Dry-run: print commands; no downloads
  --convert            (placeholder) enable FFmpeg→AIFF conversion
  --flac-only          Skip AIFF conversion/organising; keep downloaded files
  -h, --help           Show this help

Env overrides:
  RUN_LUCKY_JS=/path/to/runLuckyForTracklist.js
  SPOTIFY_LIST_JS=/path/to/spotify_list.js
EOF
}

# -----------------------
# Parse args
# -----------------------
if [[ $# -lt 1 ]]; then usage; exit 1; fi
SPOTIFY_URL=""
TIDAL_URL=""
while [[ $# -gt 0 ]]; do
  case "$1" in
    -h|--help) usage; exit 0 ;;
    --dir) OUT_DIR="$2"; shift 2 ;;
    --quality) QUALITY="$2"; shift 2 ;;
    --dry) DRY_RUN=1; shift ;;
    --convert) DO_CONVERT=1; shift ;;
    --flac-only) FLAC_ONLY=1; shift ;;
    --verbose) VERBOSE=1; shift ;;
    --quiet) QUIET=1; shift ;;
    http*spotify.com*) SPOTIFY_URL="$1"; shift ;;
    http*tidal.com*) TIDAL_URL="$1"; shift ;;
    --*)
      RUN_LUCKY_EXTRA+=("$1")
      shift
      ;;
    *)
      if [[ -z "$TRACKLIST_FILE" ]]; then
        TRACKLIST_FILE="$1"
        shift
      else
        echo "Unknown arg: $1"; usage; exit 1;
      fi
      ;;
  esac
done

if [[ -z "$SPOTIFY_URL" && -z "$TIDAL_URL" && -z "$TRACKLIST_FILE" ]]; then
  echo "Provide a Spotify or TIDAL URL, or a tracklist file path."
  usage
  exit 1
fi

# -----------------------
# Checks
# -----------------------
need() { command -v "$1" >/dev/null 2>&1 || { echo "Missing: $1"; exit 1; }; }
need node
need tidal-dl-ng
need "$RUN_LUCKY_BIN"
if [[ -z "$TRACKLIST_FILE" && -n "$SPOTIFY_URL" ]]; then
  need "$SPOTIFY_LIST_BIN"
fi
if [[ -z "$TRACKLIST_FILE" && -n "$TIDAL_URL" ]]; then
  need "$TIDAL_LIST_BIN"
fi

mkdir -p "$OUT_DIR"

# -----------------------
# Temp workspace
# -----------------------
TMP_ROOT="$(mktemp -d -t s2r.XXXXXX)"
trap 'rm -rf "$TMP_ROOT"' EXIT

TRACKS_TXT="$TRACKLIST_FILE"
if [[ -z "$TRACKLIST_FILE" ]]; then
  TRACKS_TXT="$TMP_ROOT/tracklist.txt"
  if [[ -n "$SPOTIFY_URL" ]]; then
    echo "Scraping Spotify → tracklist..."
    "$SPOTIFY_LIST_BIN" "$SPOTIFY_URL" > "$TRACKS_TXT"
  elif [[ -n "$TIDAL_URL" ]]; then
    echo "Scraping TIDAL → tracklist..."
    "$TIDAL_LIST_BIN" "$TIDAL_URL" > "$TRACKS_TXT"
  fi
fi

if [[ ! -f "$TRACKS_TXT" ]]; then
  echo "Tracklist file not found: $TRACKS_TXT"
  exit 1
fi

# -----------------------
# Display configuration summary
# -----------------------
# Try to read ORGANISED_AIFF_DIR from .env
if [[ -f "$REPO_ROOT/.env" ]]; then
  ORGANISED_AIFF_DIR=$(grep '^ORGANISED_AIFF_DIR=' "$REPO_ROOT/.env" | cut -d'=' -f2- | sed 's/^["'\'']\(.*\)["'\'']$/\1/')
fi
ORGANISED_AIFF_DIR="${ORGANISED_AIFF_DIR:-$HOME/Music/rekordbox/DROP_NEW_SONGS_HERE}"

echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
echo "Configuration:"
echo "  Tracklist:     $TRACKS_TXT"
echo "  Downloads:     $OUT_DIR (temp FLAC storage)"
echo "  Organized to:  $ORGANISED_AIFF_DIR"
echo "  Quality:       $QUALITY"
[[ "$DRY_RUN" -eq 1 ]] && echo "  Mode:          DRY RUN (no downloads)"
[[ "$FLAC_ONLY" -eq 1 ]] && echo "  Mode:          FLAC-only (no conversion)"
[[ "$VERBOSE" -eq 1 ]] && echo "  Verbose:       enabled"
[[ "$QUIET" -eq 1 ]] && echo "  Quiet:         enabled"
# Check for --by-genre flag in extra args
if [[ ${#RUN_LUCKY_EXTRA[@]} -gt 0 ]]; then
  for arg in "${RUN_LUCKY_EXTRA[@]}"; do
    [[ "$arg" == "--by-genre" ]] && echo "  Layout:        by-genre (Genre/Artist/Title.aiff)"
  done
fi
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
echo ""

# -----------------------
# Step 2: run tidal-dl-ng via local JS
# -----------------------
echo "Starting TIDAL downloads…"
RUN_LUCKY_ARGS=("$TRACKS_TXT")
# append forwarded flags (e.g., --artist-first, --quality 5)
if [[ ${#RUN_LUCKY_EXTRA[@]} -gt 0 ]]; then
  RUN_LUCKY_ARGS+=("${RUN_LUCKY_EXTRA[@]}")
fi
RUN_LUCKY_ARGS+=(--dir "$OUT_DIR" --quality "$QUALITY")
[[ "$DRY_RUN" -eq 1 ]] && RUN_LUCKY_ARGS+=(--dry)
[[ "$VERBOSE" -eq 1 ]] && RUN_LUCKY_ARGS+=(--verbose)
[[ "$QUIET" -eq 1 ]] && RUN_LUCKY_ARGS+=(--quiet)
[[ "$FLAC_ONLY" -eq 1 ]] && RUN_LUCKY_ARGS+=(--flac-only)
"$RUN_LUCKY_BIN" "${RUN_LUCKY_ARGS[@]}"

# -----------------------
# Step 4 (optional placeholder): FFmpeg → AIFF
# -----------------------
if [[ "$DO_CONVERT" -eq 1 ]]; then
  need ffmpeg
  echo "Converting to AIFF (placeholder) ..."
  while IFS= read -r -d '' f; do
    base="${f%.*}"
    aiff="${base}.aiff"
    ffmpeg -y -i "$f" -map_metadata 0 -c:a pcm_s16be "$aiff"
  done < <(find "$OUT_DIR" -type f \( -iname '*.flac' -o -iname '*.wav' -o -iname '*.mp3' -o -iname '*.m4a' \) -print0)
fi

echo "Done."
