#!/usr/bin/env bash
set -euo pipefail

# -----------------------
# Config defaults
# -----------------------
OUT_DIR="${OUT_DIR:-$HOME/Music/qobuz-dl}"   # where qobuz-dl writes
CONCURRENCY="${CONCURRENCY:-3}"              # parallel tracks for qobuz
QUALITY="${QUALITY:-6}"                      # 6 = Lossless (qobuz-dl)
DRY_RUN="${DRY_RUN:-0}"                      # 1 = show commands only
TRACKLIST_FILE=""                            # optional: reuse tracklist instead of scraping

# Flags:
#   --dir /path/to/out
#   --concurrency N
#   --quality 5|6|7|27
#   --dry
#   --tracklist /path/to/file.txt  # skip scraping, reuse a prepared list
#   --convert                      # (placeholder) enable FFmpeg conversion step later
DO_CONVERT=0

usage() {
  cat <<EOF
Usage:
  $(basename "$0") <spotify_url> [options]

Options:
  --dir DIR            Output directory for downloads (default: $OUT_DIR)
  --concurrency N      Concurrent qobuz jobs (default: $CONCURRENCY)
  --quality Q          5=320, 6=LOSSLESS, 7=24b<=96k, 27=>96k (default: $QUALITY)
  --dry                Dry-run: print qobuz commands; no downloads
  --tracklist FILE     Use an existing "Song - Artist" list; skip Spotify scraping
  --convert            (placeholder) enable FFmpeg to AIFF conversion (step 4, to be added)
  -h, --help           Show this help

Examples:
  $(basename "$0") "https://open.spotify.com/album/..." --dir "$HOME/Music/qobuz-dl" --concurrency 4
  $(basename "$0") "https://open.spotify.com/playlist/..." --dry
EOF
}

# -----------------------
# Parse args
# -----------------------
if [[ $# -lt 1 ]]; then usage; exit 1; fi
SPOTIFY_URL=""
while [[ $# -gt 0 ]]; do
  case "$1" in
    -h|--help) usage; exit 0 ;;
    --dir) OUT_DIR="$2"; shift 2 ;;
    --concurrency) CONCURRENCY="$2"; shift 2 ;;
    --quality) QUALITY="$2"; shift 2 ;;
    --dry) DRY_RUN=1; shift ;;
    --tracklist) TRACKLIST_FILE="$2"; shift 2 ;;
    --convert) DO_CONVERT=1; shift ;;
    http*spotify.com*) SPOTIFY_URL="$1"; shift ;;
    *) echo "Unknown arg: $1"; usage; exit 1 ;;
  esac
done

if [[ -z "$SPOTIFY_URL" && -z "$TRACKLIST_FILE" ]]; then
  echo "Provide a Spotify URL or --tracklist <file>."
  exit 1
fi

# -----------------------
# Checks
# -----------------------
need() { command -v "$1" >/dev/null 2>&1 || { echo "Missing: $1"; exit 1; }; }

need node
need qobuz-dl

# Ensure our Node CLI exists
if ! command -v run-lucky >/dev/null 2>&1; then
  echo "run-lucky not found. From project root run: npm i && npm link"
  exit 1
fi

# spotify_list.js for scraping
if [[ -z "$TRACKLIST_FILE" ]]; then
  [[ -f "./spotify_list.js" ]] || { echo "spotify_list.js not found in current dir."; exit 1; }
fi

mkdir -p "$OUT_DIR"

# -----------------------
# Create temp workspace
# -----------------------
TMP_ROOT="$(mktemp -d -t s2r.XXXXXX)"
trap 'rm -rf "$TMP_ROOT"' EXIT

TRACKS_TXT="$TRACKLIST_FILE"
if [[ -z "$TRACKLIST_FILE" ]]; then
  TRACKS_TXT="$TMP_ROOT/tracklist.txt"
  echo "Scraping Spotify → tracklist..."
  node ./spotify_list.js "$SPOTIFY_URL" > "$TRACKS_TXT"
fi

LINES=$(grep -c ' - ' "$TRACKS_TXT" || true)
if [[ "${LINES:-0}" -eq 0 ]]; then
  echo "No valid 'Song - Artist' lines found in $TRACKS_TXT"
  exit 1
fi
echo "Found $LINES tracks."

# -----------------------
# Step 2: qobuz-dl lucky
# -----------------------
echo "Starting qobuz downloads…"
if [[ "$DRY_RUN" -eq 1 ]]; then
  run-lucky "$TRACKS_TXT" --dir "$OUT_DIR" --concurrency "$CONCURRENCY" --quality "$QUALITY" --dry
else
  run-lucky "$TRACKS_TXT" --dir "$OUT_DIR" --concurrency "$CONCURRENCY" --quality "$QUALITY"
fi

# -----------------------
# Step 3 (hook): prefer LOSSLESS, else 320
# We'll wire this in the Node runner next so it retries with -q 5 when -q 6 fails.
# -----------------------

# -----------------------
# Step 4 (hook): FFmpeg → AIFF preserving tags
# We'll flip this on when we finish step 3. Example pipeline kept here for reference:
# -----------------------
if [[ "$DO_CONVERT" -eq 1 ]]; then
  need ffmpeg
  echo "Converting to AIFF (placeholder demo) ..."
  # Example: convert any FLAC/MP3/WAV under OUT_DIR to AIFF next to originals.
  # NOTE: We'll refine discovery & idempotency later.
  while IFS= read -r -d '' f; do
    base="${f%.*}"
    aiff="${base}.aiff"
    # pcm_s16be is typical AIFF encoding; map metadata from source
    ffmpeg -y -i "$f" -map_metadata 0 -c:a pcm_s16be "$aiff"
  done < <(find "$OUT_DIR" -type f \( -iname '*.flac' -o -iname '*.wav' -o -iname '*.mp3' -o -iname '*.m4a' \) -print0)
fi

echo "Done."